RADOS client protocol
=====================

This is very incomplete, but one must start somewhere.

Basics
------

Requests are MOSDOp messages.  Replies are MOSDOpReply messages.

An object request is targetted at an hobject_t, which includes a pool,
hash value, object name, placement key (usually empty), and snapid.

The hash value is a 32-bit hash value, normally generated by hashing
the object name, and then folded onto the current number of PGs in a
pool.  The hobject_t can be arbitrarily constructed, though, which any
hash value, and name.  Note that in the MOSDOp these components are
spread across several fields and not logically assembled in an actual
hobject_t member.

A request can also target a PG.  In this case, the *ps* value matches
a specific PG, the object name is empty, and (hopefully) the ops in
the request are PG ops.

Either way, the request ultimately targets a PG.  The client sends the
request to the primary for the assocated PG.

Each request is assigned a unique tid.

Resends
-------

If there is a connection drop, the client will resend any outstanding
requets.

Any time there is a PG mapping change such that the primary changes,
the client is responsible for resending the request.  Note that
although there may be an interval change from the OSD's perspective
(triggering PG peering), if the primary doesn't change then the client
need not resend.

There are a few exceptions to this rule:

 * There is a last_force_op_resend field in the pg_pool_t in the
   OSDMap.  If this changes, then the clients are forced to resend any
   outstanding requests. (This happens when tiering is adjusted, for
   example.)
 * Some requests are such that they are resent on *any* PG interval
   change, as defined by pg_interval_t's is_new_interval() (the same
   criteria used by peering in the OSD).
 * If the PAUSE OSDMap flag is set and unset.

Each time a request is sent to the OSD the *attempt* field is incremented. The
first time it is 0, the next 1, etc.

Backoff
-------

Ordinarily the OSD will simply queue any requests it can't immeidately
process in memory until such time as it can.  This can become
problematic because the OSD limits the total amount of RAM consuemd by
incoming messages: if the threshold is reached, new messages will not
be read off the network socket, causing backpressure through the
network.

In some cases, though, the OSD knows or expects that a PG or object
will be unavailable for some time and does not want to consume memory
by queuing requests.  In these cases it can send a MOSDBackoff message
to the client.

There are two types of backoff: a *PG* backoff will plug all requests
targetting a single PG at the client, while an *object* backoff will
plug all requests targetting a single object.

The backoff message includes:

#. the op code (block pg, unblock pg, block oid, unblock oid)
#. the PG or object id (oid)
#. the epoch in which it is sent
#. the first *tid* of the client request (MOSDOp) that triggered the backoff, and
#. the *attempt* of that request (to distinguish between different
   instances of the same request sent by the client)

When the client receives a backoff, it is now responsible for
resending the given request (and any that followed it which targetted
the same PG or oid) when the backoff is removed.  This resend looks like any
other resend by the client: the attempt field is incremented and an MOSDOp
message is sent.

When the OSD installs the backoff, it discards the request, and any
requests that follow it from the same client.  (This can happen when
the client has multiple requests in flight when the backoff is
installed.)

A backoff can be removed in three ways:

#. The OSD sends a backoff message expliciting unblocking a PG or object.
#. The PG primary changes, triggering a resend in the same way as
   other outstanding requests (see above).
#. The client connect to the OSD is reset.  In this case, the backoff state
   is discarded and all requests for the OSD are resent.
